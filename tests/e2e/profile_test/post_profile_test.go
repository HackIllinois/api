package tests

import (
	"context"
	"net/http"
	"reflect"
	"testing"

	profile_models "github.com/HackIllinois/api/services/profile/models"
	"go.mongodb.org/mongo-driver/bson"
)

func TestPostProfile(t *testing.T) {
	defer DropDatabases()
	profile_info := profile_models.Profile{
		ID:        "12345", // should be ignored by API as API will generate this
		FirstName: "John",
		LastName:  "Smith",
		Discord:   "discord",
		AvatarUrl: "url",
	}

	received_profile := profile_models.Profile{}
	response, err := admin_client.New().Post("/profile/").BodyJSON(profile_info).ReceiveSuccess(&received_profile)
	if err != nil {
		t.Fatalf("Unable to make request")
	}

	if response.StatusCode != http.StatusOK {
		t.Errorf("Request returned HTTP error %d", response.StatusCode)
	}

	profile_info.ID = received_profile.ID // assume the received ID is correct as it was generated by the API

	// check if the profile in response is correct
	if !reflect.DeepEqual(received_profile, profile_info) {
		t.Errorf("Wrong event info. Expected %v, got %v", profile_info, received_profile)
	}

	// check if the profile was added to the database correctly
	filter := bson.M{
		"id": profile_info.ID,
	}
	actual_profile_db := profile_models.Profile{}
	res := client.Database(profile_db_name).Collection("profiles").FindOne(context.Background(), filter)

	err = res.Decode(&actual_profile_db)

	if err != nil {
		t.Fatalf("Failed to decode profile: %v", err)
	}

	if !reflect.DeepEqual(actual_profile_db, profile_info) {
		t.Errorf("Wrong event info from database. Expected %v, got %v", profile_info, actual_profile_db)
	}
}

func TestUnauthenticatedPostProfile(t *testing.T) {
	defer DropDatabases()
	profile_info := profile_models.Profile{
		ID:        "12345",
		FirstName: "John",
		LastName:  "Smith",
		Discord:   "discord",
		AvatarUrl: "url",
	}

	response, err := unauthenticated_client.New().Post("/profile/").BodyJSON(profile_info).ReceiveSuccess(struct{}{})
	if err != nil {
		t.Fatalf("Unable to make request")
	}

	if response.StatusCode != http.StatusForbidden {
		t.Errorf("Unauthenticated attendee able to access endpoint that requires authentication")
	}

	// check if database did not add profile
	filter := bson.M{
		"firstName": profile_info.FirstName,
		"lastName":  profile_info.LastName,
	}
	CheckDatabaseProfileNotFound(t, filter)
}

func TestBadPostProfile(t *testing.T) {
	defer DropDatabases()
	profile_info := profile_models.Profile{
		ID:        "12345",
		FirstName: "John",
	}

	received_profile := profile_models.Profile{}
	response, err := admin_client.New().Post("/profile/").BodyJSON(profile_info).ReceiveSuccess(&received_profile)
	if err != nil {
		t.Fatalf("Unable to make request")
	}

	if response.StatusCode != http.StatusInternalServerError {
		t.Errorf("Profile with not enough fields can be inserted")
	}

	// check if database did not add profile
	filter := bson.M{
		"firstName": profile_info.FirstName,
	}
	CheckDatabaseProfileNotFound(t, filter)
}

func TestPostProfileWithExtraFields(t *testing.T) {
	defer DropDatabases()
	profile_info := profile_models.Profile{
		ID:        "12345", // should be ignored by API as API will generate this
		FirstName: "John",
		LastName:  "Smith",
		Points:    1337,
		Discord:   "discord",
		AvatarUrl: "url",
		FoodWave:  2,
	}

	received_profile := profile_models.Profile{}
	response, err := admin_client.New().Post("/profile/").BodyJSON(profile_info).ReceiveSuccess(&received_profile)
	if err != nil {
		t.Fatalf("Unable to make request")
	}

	if response.StatusCode != http.StatusOK {
		t.Errorf("Request returned HTTP error %d", response.StatusCode)
	}

	profile_info.ID = received_profile.ID // assume the received ID is correct as it was generated by the API
	profile_info.Points = 0               // Points cannot be set via POST /profile/
	profile_info.FoodWave = 0             // Food wave cannot be set via POST /profile/

	// check if the profile in response is correct
	if !reflect.DeepEqual(received_profile, profile_info) {
		t.Errorf("Wrong event info. Expected %v, got %v", profile_info, received_profile)
	}

	// check if the profile was added to the database correctly
	filter := bson.M{
		"id": profile_info.ID,
	}
	actual_profile_db := profile_models.Profile{}
	res := client.Database(profile_db_name).Collection("profiles").FindOne(context.Background(), filter)

	err = res.Decode(&actual_profile_db)

	if err != nil {
		t.Fatalf("Failed to decode profile: %v", err)
	}

	if !reflect.DeepEqual(actual_profile_db, profile_info) {
		t.Errorf("Wrong event info from database. Expected %v, got %v", profile_info, actual_profile_db)
	}
}
